<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­åŒ»æ™ºèƒ½é—®è¯Š - ä¸“ä¸šç®¡ç†åå°</title>
    <!-- å¼•å…¥ Ant Design æ ·å¼ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@4.24.15/dist/antd.min.css" />
    <style>
        body { background-color: #f0f2f5; margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
        .admin-layout { min-height: 100vh; }
        .admin-header { background: #fff; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 4px rgba(0,21,41,.08); position: sticky; top: 0; z-index: 10; }
        .admin-logo { font-size: 18px; font-weight: bold; color: #1890ff; display: flex; align-items: center; }
        .admin-logo img { height: 32px; margin-right: 12px; }
        .admin-content { padding: 24px; }
        .table-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
        .table-operations { margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        .search-input { width: 320px; }
        
        /* ç™»å½•é¡µæ ·å¼ */
        .login-container { height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); }
        .login-box { width: 400px; padding: 40px; background: #fff; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .login-title { text-align: center; margin-bottom: 32px; font-size: 24px; color: #1f1f1f; font-weight: 600; }
        
        /* ç»Ÿè®¡å¡ç‰‡æ ·å¼ */
        .stat-card { border-radius: 8px; transition: all 0.3s; }
        .stat-card:hover { transform: translateY(-4px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .stat-value { font-size: 28px; font-weight: bold; color: #1890ff; }
        .stat-label { color: #8c8c8c; margin-top: 4px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- åŸºç¡€åº“åŠ è½½ -->
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment/locale/zh-cn.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/antd@4.24.15/dist/antd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ant-design/icons@4.7.0/dist/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;
        const { 
            Layout, Table, Button, Input, Space, Modal, Form, 
            message, Popconfirm, Card, Typography, Tag, Row, Col, Statistic, Avatar, Dropdown, Menu, Radio
        } = antd;
        const { Header, Content } = Layout;
        const { Search } = Input;
        const { Title, Text } = Typography;

        // å…¨å±€é”™è¯¯æ•è·
        window.onerror = (msg, url, line, col, error) => {
            console.error('System Error:', {msg, url, line, col, error});
            return false;
        };

        // å›¾æ ‡ç»„ä»¶åŒ…è£…å™¨
        const SafeIcon = ({ name, fallback }) => {
            try {
                const lib = window.AntDesignIcons || window.icons || {};
                const IconComp = lib[name];
                return IconComp ? React.createElement(IconComp) : <span>{fallback}</span>;
            } catch (e) {
                return <span>{fallback}</span>;
            }
        };

        const UserIcon = () => <SafeIcon name="UserOutlined" fallback="ğŸ‘¤" />;
        const LockIcon = () => <SafeIcon name="LockOutlined" fallback="ğŸ”’" />;
        const LogoutIcon = () => <SafeIcon name="LogoutOutlined" fallback="ğŸšª" />;
        const DatabaseIcon = () => <SafeIcon name="DatabaseOutlined" fallback="ğŸ“" />;
        const BulbIcon = () => <SafeIcon name="BulbOutlined" fallback="ğŸ’¡" />;
        const TeamIcon = () => <SafeIcon name="TeamOutlined" fallback="ğŸ‘¥" />;
        const FileTextIcon = () => <SafeIcon name="FileTextOutlined" fallback="ğŸ“„" />;
        const ReadIcon = () => <SafeIcon name="ReadOutlined" fallback="ğŸ“–" />;

        // ç©´ä½ç®¡ç†ç»„ä»¶
        const AcupunctureManager = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(false);
            const [isModalVisible, setIsModalVisible] = useState(false);
            const [editingItem, setEditingItem] = useState(null);
            const [form] = Form.useForm();

            const loadData = async () => {
                setLoading(true);
                try {
                    const res = await api.fetchAcupunctureData();
                    if (res.code === 200) setData(res.data);
                } catch (err) {
                    message.error('åŠ è½½ç©´ä½æ•°æ®å¤±è´¥');
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => { loadData(); }, []);

            const handleSave = async () => {
                try {
                    const values = await form.validateFields();
                    // å¤„ç† points å’Œ dietary å­—ç¬¦ä¸²è½¬æ•°ç»„
                    const formattedValues = {
                        ...values,
                        points: typeof values.points === 'string' ? JSON.parse(values.points) : values.points,
                        dietary: typeof values.dietary === 'string' ? JSON.parse(values.dietary) : values.dietary
                    };

                    let newData;
                    if (editingItem) {
                        newData = data.map(item => item.id === editingItem.id ? { ...item, ...formattedValues } : item);
                    } else {
                        newData = [...data, { ...formattedValues, id: Date.now().toString() }];
                    }

                    const res = await api.saveAcupunctureData(newData);
                    if (res.code === 200) {
                        message.success('ä¿å­˜æˆåŠŸ');
                        setIsModalVisible(false);
                        loadData();
                    }
                } catch (err) {
                    message.error('ä¿å­˜å¤±è´¥: ' + err.message);
                }
            };

            const handleDelete = async (id) => {
                const newData = data.filter(item => item.id !== id);
                const res = await api.saveAcupunctureData(newData);
                if (res.code === 200) {
                    message.success('åˆ é™¤æˆåŠŸ');
                    loadData();
                }
            };

            const columns = [
                { title: 'åç§°', dataIndex: 'name', key: 'name', width: 120 },
                { title: 'æè¿°', dataIndex: 'desc', key: 'desc', ellipsis: true },
                { 
                    title: 'æ“ä½œ', 
                    key: 'action', 
                    width: 150, 
                    render: (_, record) => (
                        <Space>
                            <Button type="link" onClick={() => { 
                                setEditingItem(record); 
                                form.setFieldsValue({
                                    ...record,
                                    points: JSON.stringify(record.points, null, 2),
                                    dietary: JSON.stringify(record.dietary, null, 2)
                                }); 
                                setIsModalVisible(true); 
                            }}>ç¼–è¾‘</Button>
                            <Popconfirm title="ç¡®å®šåˆ é™¤ï¼Ÿ" onConfirm={() => handleDelete(record.id)}>
                                <Button type="link" danger>åˆ é™¤</Button>
                            </Popconfirm>
                        </Space>
                    )
                }
            ];

            return (
                <Card title="ç©´ä½ç™¾ç§‘ç®¡ç†" extra={<Button type="primary" onClick={() => { setEditingItem(null); form.resetFields(); setIsModalVisible(true); }}>æ–°å¢ç±»åˆ«</Button>}>
                    <Table columns={columns} dataSource={data} rowKey="id" loading={loading} />
                    <Modal title={editingItem ? 'ç¼–è¾‘ç©´ä½ç±»åˆ«' : 'æ–°å¢ç©´ä½ç±»åˆ«'} visible={isModalVisible} onOk={handleSave} onCancel={() => setIsModalVisible(false)} width={800}>
                        <Form form={form} layout="vertical">
                            <Form.Item name="name" label="åç§°" rules={[{ required: true }]}><Input /></Form.Item>
                            <Form.Item name="icon" label="å›¾æ ‡ (Emoji)" rules={[{ required: true }]}><Input /></Form.Item>
                            <Form.Item name="desc" label="æè¿°" rules={[{ required: true }]}><Input.TextArea /></Form.Item>
                            <Form.Item name="points" label="ç©´ä½åˆ—è¡¨ (JSON æ ¼å¼)" rules={[{ required: true }]}>
                                <Input.TextArea rows={8} placeholder='[{"name": "...", "meridian": "...", "location": "...", "function": "...", "method": "..."}]' />
                            </Form.Item>
                            <Form.Item name="dietary" label="é£Ÿç–—åˆ—è¡¨ (JSON æ ¼å¼)" rules={[{ required: true }]}>
                                <Input.TextArea rows={8} placeholder='[{"name": "...", "ingredients": "...", "practice": "...", "function": "...", "note": "..."}]' />
                            </Form.Item>
                        </Form>
                    </Modal>
                </Card>
            );
        };

        // ç—‡çŠ¶å¯¹ç…§ç®¡ç†ç»„ä»¶
        const SymptomComparisonManager = () => {
            const [data, setData] = useState({});
            const [loading, setLoading] = useState(false);
            const [isModalVisible, setIsModalVisible] = useState(false);
            const [editingKey, setEditingKey] = useState(null);
            const [form] = Form.useForm();

            const loadData = async () => {
                setLoading(true);
                try {
                    const res = await api.fetchSymptomComparisonData();
                    if (res.code === 200) setData(res.data);
                } catch (err) {
                    message.error('åŠ è½½ç—‡çŠ¶å¯¹ç…§æ•°æ®å¤±è´¥');
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => { loadData(); }, []);

            const handleSave = async () => {
                try {
                    const values = await form.validateFields();
                    const formattedComparisons = typeof values.comparisons === 'string' ? JSON.parse(values.comparisons) : values.comparisons;
                    
                    const newData = { ...data };
                    if (editingKey && editingKey !== values.symptom) {
                        delete newData[editingKey];
                    }
                    newData[values.symptom] = formattedComparisons;

                    const res = await api.saveSymptomComparisonData(newData);
                    if (res.code === 200) {
                        message.success('ä¿å­˜æˆåŠŸ');
                        setIsModalVisible(false);
                        loadData();
                    }
                } catch (err) {
                    message.error('ä¿å­˜å¤±è´¥: ' + err.message);
                }
            };

            const handleDelete = async (key) => {
                const newData = { ...data };
                delete newData[key];
                const res = await api.saveSymptomComparisonData(newData);
                if (res.code === 200) {
                    message.success('åˆ é™¤æˆåŠŸ');
                    loadData();
                }
            };

            const columns = [
                { title: 'ç—‡çŠ¶å…³é”®è¯', dataIndex: 'symptom', key: 'symptom', width: 150 },
                { 
                    title: 'å¯¹ç…§é¡¹æ•°é‡', 
                    key: 'count', 
                    render: (_, record) => record.comparisons.length 
                },
                { 
                    title: 'æ“ä½œ', 
                    key: 'action', 
                    width: 150, 
                    render: (_, record) => (
                        <Space>
                            <Button type="link" onClick={() => { 
                                setEditingKey(record.symptom); 
                                form.setFieldsValue({
                                    symptom: record.symptom,
                                    comparisons: JSON.stringify(record.comparisons, null, 2)
                                }); 
                                setIsModalVisible(true); 
                            }}>ç¼–è¾‘</Button>
                            <Popconfirm title="ç¡®å®šåˆ é™¤ï¼Ÿ" onConfirm={() => handleDelete(record.symptom)}>
                                <Button type="link" danger>åˆ é™¤</Button>
                            </Popconfirm>
                        </Space>
                    )
                }
            ];

            const tableData = Object.keys(data).map(key => ({
                symptom: key,
                comparisons: data[key]
            }));

            return (
                <Card title="ç—‡çŠ¶å¯¹ç…§è‡ªæŸ¥ç®¡ç†" extra={<Button type="primary" onClick={() => { setEditingKey(null); form.resetFields(); setIsModalVisible(true); }}>æ–°å¢ç—‡çŠ¶</Button>}>
                    <Table columns={columns} dataSource={tableData} rowKey="symptom" loading={loading} />
                    <Modal title={editingKey ? 'ç¼–è¾‘ç—‡çŠ¶å¯¹ç…§' : 'æ–°å¢ç—‡çŠ¶å¯¹ç…§'} visible={isModalVisible} onOk={handleSave} onCancel={() => setIsModalVisible(false)} width={800}>
                        <Form form={form} layout="vertical">
                            <Form.Item name="symptom" label="ç—‡çŠ¶å…³é”®è¯" rules={[{ required: true }]}><Input placeholder="å¦‚ï¼šå’½ç—›ã€å‘çƒ­" /></Form.Item>
                            <Form.Item name="comparisons" label="å¯¹ç…§è¯¦æƒ… (JSON æ ¼å¼)" rules={[{ required: true }]}>
                                <Input.TextArea rows={12} placeholder='[{"title": "...", "feature": "...", "accompanying_signs": "...", "self_observation_tip": "...", "diet_advice": "...", "living_advice": "...", "treatment_suggestion": "..."}]' />
                            </Form.Item>
                        </Form>
                    </Modal>
                </Card>
            );
        };

        // ä¸­åŒ»å¸¸è¯†ç®¡ç†ç»„ä»¶
        const KnowledgeManager = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(false);
            const [isModalVisible, setIsModalVisible] = useState(false);
            const [editingItem, setEditingItem] = useState(null);
            const [form] = Form.useForm();

            const loadData = async () => {
                setLoading(true);
                try {
                    const res = await api.fetchKnowledgeData();
                    if (res.code === 200) setData(res.data);
                } catch (err) {
                    message.error('åŠ è½½ä¸­åŒ»å¸¸è¯†æ•°æ®å¤±è´¥');
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => { loadData(); }, []);

            const handleSave = async () => {
                try {
                    const values = await form.validateFields();
                    const formattedSections = typeof values.sections === 'string' ? JSON.parse(values.sections) : values.sections;
                    
                    let newData;
                    if (editingItem) {
                        newData = data.map(item => item.id === editingItem.id ? { ...item, ...values, sections: formattedSections } : item);
                    } else {
                        newData = [...data, { ...values, id: Date.now().toString(), sections: formattedSections }];
                    }

                    const res = await api.saveKnowledgeData(newData);
                    if (res.code === 200) {
                        message.success('ä¿å­˜æˆåŠŸ');
                        setIsModalVisible(false);
                        loadData();
                    }
                } catch (err) {
                    message.error('ä¿å­˜å¤±è´¥: ' + err.message);
                }
            };

            const handleDelete = async (id) => {
                const newData = data.filter(item => item.id !== id);
                const res = await api.saveKnowledgeData(newData);
                if (res.code === 200) {
                    message.success('åˆ é™¤æˆåŠŸ');
                    loadData();
                }
            };

            const columns = [
                { title: 'æ ‡é¢˜', dataIndex: 'title', key: 'title', width: 200 },
                { title: 'å›¾æ ‡', dataIndex: 'icon', key: 'icon', width: 80 },
                { 
                    title: 'å†…å®¹é¡¹æ•°é‡', 
                    key: 'count', 
                    width: 120,
                    render: (_, record) => record.sections.length 
                },
                { 
                    title: 'æ“ä½œ', 
                    key: 'action', 
                    width: 150, 
                    render: (_, record) => (
                        <Space>
                            <Button type="link" onClick={() => { 
                                setEditingItem(record); 
                                form.setFieldsValue({
                                    ...record,
                                    sections: JSON.stringify(record.sections, null, 2)
                                }); 
                                setIsModalVisible(true); 
                            }}>ç¼–è¾‘</Button>
                            <Popconfirm title="ç¡®å®šåˆ é™¤ï¼Ÿ" onConfirm={() => handleDelete(record.id)}>
                                <Button type="link" danger>åˆ é™¤</Button>
                            </Popconfirm>
                        </Space>
                    )
                }
            ];

            return (
                <Card title="ä¸­åŒ»å¸¸è¯†ç®¡ç†" extra={<Button type="primary" onClick={() => { setEditingItem(null); form.resetFields(); setIsModalVisible(true); }}>æ–°å¢å¸¸è¯†</Button>}>
                    <Table columns={columns} dataSource={data} rowKey="id" loading={loading} />
                    <Modal title={editingItem ? 'ç¼–è¾‘ä¸­åŒ»å¸¸è¯†' : 'æ–°å¢ä¸­åŒ»å¸¸è¯†'} visible={isModalVisible} onOk={handleSave} onCancel={() => setIsModalVisible(false)} width={800}>
                        <Form form={form} layout="vertical">
                            <Form.Item name="title" label="æ ‡é¢˜" rules={[{ required: true }]}><Input placeholder="å¦‚ï¼šè®¤è¯†ä¸­åŒ»ã€ç»ç»œå…»ç”Ÿ" /></Form.Item>
                            <Form.Item name="icon" label="å›¾æ ‡ (Emoji)" rules={[{ required: true }]}><Input placeholder="å¦‚ï¼šğŸŒ¿ã€ğŸ§˜" /></Form.Item>
                            <Form.Item name="sections" label="å¸¸è¯†å†…å®¹ (JSON æ ¼å¼)" rules={[{ required: true }]}>
                                <Input.TextArea rows={15} placeholder='[{"title": "...", "content": "..."}]' />
                            </Form.Item>
                        </Form>
                    </Modal>
                </Card>
            );
        };

        // API å°è£…
        const api = {
            async fetchSyndromes(params) {
                const query = new URLSearchParams(params).toString();
                const res = await fetch(`/api/admin/syndromes?${query}`);
                return res.json();
            },
            async saveSyndrome(data) {
                const res = await fetch('/api/admin/syndrome', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                return res.json();
            },
            async deleteSyndromes(ids) {
                const res = await fetch('/api/admin/syndromes', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ids })
                });
                return res.json();
            },
            async fetchPatientStats(timeRange = 'all') {
                const res = await fetch(`/api/admin/patient-stats?timeRange=${timeRange}`);
                return res.json();
            },
            async fetchDiagnosisRecords(params) {
                const query = new URLSearchParams(params).toString();
                const res = await fetch(`/api/admin/diagnosis-records?${query}`);
                return res.json();
            },
            async fetchConstitutionStats(timeRange = 'all') {
                const res = await fetch(`/api/admin/constitution-stats?timeRange=${timeRange}`);
                return res.json();
            },
            async fetchAcupunctureData() {
                const res = await fetch('/api/admin/acupuncture-data');
                return res.json();
            },
            async saveAcupunctureData(data) {
                const res = await fetch('/api/admin/acupuncture-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                return res.json();
            },
            async fetchSymptomComparisonData() {
                const res = await fetch('/api/admin/symptom-comparison');
                return res.json();
            },
            async saveSymptomComparisonData(data) {
                const res = await fetch('/api/admin/symptom-comparison', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                return res.json();
            },
            async fetchKnowledgeData() {
                const res = await fetch('/api/admin/knowledge');
                return res.json();
            },
            async saveKnowledgeData(data) {
                const res = await fetch('/api/admin/knowledge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                return res.json();
            }
        };

        // ç™»å½•é¡µé¢
        const LoginPage = ({ onLogin }) => {
            const [loading, setLoading] = useState(false);
            const onFinish = (values) => {
                setLoading(true);
                setTimeout(() => {
                    if (values.username === 'admin' && values.password === '123456') {
                        message.success('ç™»å½•æˆåŠŸ');
                        onLogin(values.username);
                    } else {
                        message.error('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
                    }
                    setLoading(false);
                }, 800);
            };
            return (
                <div className="login-container">
                    <div className="login-box">
                        <div className="login-title">ä¸­åŒ»é—®è¯Šåå°ç™»å½•</div>
                        <Form onFinish={onFinish} layout="vertical" size="large">
                            <Form.Item name="username" rules={[{ required: true, message: 'è¯·è¾“å…¥ç”¨æˆ·å' }]}>
                                <Input prefix={<UserIcon />} placeholder="ç”¨æˆ·å" />
                            </Form.Item>
                            <Form.Item name="password" rules={[{ required: true, message: 'è¯·è¾“å…¥å¯†ç ' }]}>
                                <Input.Password prefix={<LockIcon />} placeholder="å¯†ç " />
                            </Form.Item>
                            <Form.Item>
                                <Button type="primary" htmlType="submit" block loading={loading}>ç™»å½•</Button>
                            </Form.Item>
                        </Form>
                    </div>
                </div>
            );
        };

        // ç®¡ç†é¢æ¿
        const AdminPanel = ({ user, onLogout }) => {
            const [data, setData] = useState([]);
            const [patientStats, setPatientStats] = useState([]);
            const [constitutionStats, setConstitutionStats] = useState([]);
            const [diagnosisRecords, setDiagnosisRecords] = useState([]);
            const [timeRange, setTimeRange] = useState('all');
            const [loading, setLoading] = useState(false);
            const [recordLoading, setRecordLoading] = useState(false);
            const [total, setTotal] = useState(0);
            const [recordTotal, setRecordTotal] = useState(0);
            const [current, setCurrent] = useState(1);
            const [recordCurrent, setRecordCurrent] = useState(1);
            const [pageSize, setPageSize] = useState(10);
            const [keyword, setKeyword] = useState('');
            const [isModalVisible, setIsModalVisible] = useState(false);
            const [editingItem, setEditingItem] = useState(null);
            const [activeTab, setActiveTab] = useState('1');
            const [form] = Form.useForm();
            const chartRef = useRef(null);
            const constitutionChartRef = useRef(null);
            const chartInstance = useRef(null);
            const constitutionChartInstance = useRef(null);

            const loadData = useCallback(async (page = current, size = pageSize, kw = keyword, tr = timeRange) => {
                setLoading(true);
                try {
                    const [res, statsRes, constRes] = await Promise.all([
                        api.fetchSyndromes({ current: page, pageSize: size, keyword: kw }),
                        api.fetchPatientStats(tr),
                        api.fetchConstitutionStats(tr)
                    ]);
                    if (res.code === 200) {
                        setData(res.data.list);
                        setTotal(res.data.total);
                    }
                    if (statsRes.code === 200) {
                        setPatientStats(statsRes.data);
                        updateChart(statsRes.data);
                    }
                    if (constRes.code === 200) {
                        setConstitutionStats(constRes.data);
                        updateConstitutionChart(constRes.data);
                    }
                } catch (err) {
                    message.error('åŠ è½½æ•°æ®å¤±è´¥');
                } finally {
                    setLoading(false);
                }
            }, [current, pageSize, keyword, timeRange]);

            const loadRecords = useCallback(async (page = recordCurrent) => {
                setRecordLoading(true);
                try {
                    const res = await api.fetchDiagnosisRecords({ current: page, pageSize: 10 });
                    if (res.code === 200) {
                        setDiagnosisRecords(res.data.list);
                        setRecordTotal(res.data.total);
                    }
                } catch (err) {
                    message.error('åŠ è½½è®°å½•å¤±è´¥');
                } finally {
                    setRecordLoading(false);
                }
            }, [recordCurrent]);

            const updateChart = (statsData) => {
                if (!chartRef.current) return;
                if (!chartInstance.current) {
                    chartInstance.current = echarts.init(chartRef.current);
                }
                chartInstance.current.setOption({
                    title: { text: 'ç—…ç—‡åˆ†å¸ƒæ¯”ä¾‹', left: 'center' },
                    tooltip: { trigger: 'item', formatter: '{b} : {c} ({d}%)' },
                    series: [{
                        type: 'pie',
                        radius: '55%',
                        data: statsData.map(d => ({ name: d.name, value: d.value })),
                        emphasis: { itemStyle: { shadowBlur: 10, shadowColor: 'rgba(0,0,0,0.5)' } }
                    }]
                });
            };

            const updateConstitutionChart = (statsData) => {
                if (!constitutionChartRef.current) return;
                if (!constitutionChartInstance.current) {
                    constitutionChartInstance.current = echarts.init(constitutionChartRef.current);
                }
                constitutionChartInstance.current.setOption({
                    title: { text: 'æµ‹è¯•äººä½“è´¨åˆ†å¸ƒ', left: 'center' },
                    tooltip: { trigger: 'item', formatter: '{b} : {c} ({d}%)' },
                    series: [{
                        type: 'pie',
                        radius: '55%',
                        data: statsData.map(d => ({ name: d.name, value: d.value })),
                        color: ['#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
                        emphasis: { itemStyle: { shadowBlur: 10, shadowColor: 'rgba(0,0,0,0.5)' } }
                    }]
                });
            };

            useEffect(() => {
                loadData();
                loadRecords();
                const resize = () => {
                    chartInstance.current?.resize();
                    constitutionChartInstance.current?.resize();
                };
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, [loadData, loadRecords]);

            const columns = [
                { title: 'è¯å‹åç§°', dataIndex: 'name', key: 'name', width: 140, render: t => <Tag color="blue">{t}</Tag> },
                { title: 'è¾¨è¯æè¿°', dataIndex: 'description', key: 'description', ellipsis: true },
                { title: 'æ²»æ³•åŸåˆ™', dataIndex: 'treatment_principle', key: 'treatment_principle', width: 180 },
                { 
                    title: 'æ“ä½œ', 
                    key: 'action', 
                    width: 150, 
                    render: (_, record) => (
                        <Space>
                            <Button type="link" onClick={() => { setEditingItem(record); form.setFieldsValue(record); setIsModalVisible(true); }}>ç¼–è¾‘</Button>
                            <Popconfirm title="ç¡®å®šåˆ é™¤ï¼Ÿ" onConfirm={async () => {
                                await api.deleteSyndromes([record.id]);
                                message.success('åˆ é™¤æˆåŠŸ');
                                loadData();
                            }}>
                                <Button type="link" danger>åˆ é™¤</Button>
                            </Popconfirm>
                        </Space>
                    )
                }
            ];

            const recordColumns = [
                { title: 'ID', dataIndex: 'id', key: 'id', width: 80 },
                { title: 'è¯Šæ–­æ—¶é—´', dataIndex: 'timestamp', key: 'timestamp', width: 180, render: t => moment(t).format('YYYY-MM-DD HH:mm:ss') },
                { title: 'ç¡®è¯Šè¯å‹', dataIndex: 'syndrome', key: 'syndrome', render: t => <Tag color="green">{t}</Tag> },
                { title: 'çŠ¶æ€', key: 'status', width: 100, render: () => <Tag color="processing">å·²å®Œæˆ</Tag> }
            ];

            return (
                <Layout className="admin-layout">
                    <Header className="admin-header">
                        <div className="admin-logo">ğŸŒ¿ ä¸­åŒ»æ™ºèƒ½é—®è¯Šåå°</div>
                        <Dropdown overlay={<Menu><Menu.Item key="logout" onClick={onLogout} icon={<LogoutIcon />}>é€€å‡ºç™»å½•</Menu.Item></Menu>}>
                            <Space style={{ cursor: 'pointer' }}>
                                <Avatar icon={<UserIcon />} />
                                <Text strong>{user}</Text>
                            </Space>
                        </Dropdown>
                    </Header>
                    <Content className="admin-content">
                        <Row gutter={[24, 24]} style={{ marginBottom: 24 }}>
                            <Col span={6}><Card bordered={false}><Statistic title="è¯å‹æ€»æ•°" value={total} prefix={<DatabaseIcon />} /></Card></Col>
                            <Col span={6}><Card bordered={false}><Statistic title="å¼•æ“çŠ¶æ€" value="è¿è¡Œä¸­" prefix={<BulbIcon />} valueStyle={{ color: '#52c41a' }} /></Card></Col>
                            <Col span={6}><Card bordered={false}><Statistic title="ç´¯è®¡å’¨è¯¢" value={recordTotal} prefix={<TeamIcon />} /></Card></Col>
                            <Col span={6}><Card bordered={false}><Statistic title="ç³»ç»ŸçŠ¶æ€" value="æ­£å¸¸" prefix={<BulbIcon />} valueStyle={{ color: '#faad14' }} /></Card></Col>
                        </Row>
                        
                        <antd.Tabs activeKey={activeTab} onChange={setActiveTab} type="card" style={{ background: '#fff', padding: '16px', borderRadius: '8px' }}>
                            <antd.Tabs.TabPane tab="æ•°æ®æ¦‚è§ˆ" key="1">
                                <Row gutter={[24, 24]}>
                                    <Col span={12}>
                                        <Card title="ç—…ç—‡åˆ†å¸ƒ" className="table-card" bordered={false} extra={
                                            <Radio.Group value={timeRange} onChange={e => setTimeRange(e.target.value)} size="small">
                                                <Radio.Button value="all">å…¨éƒ¨</Radio.Button>
                                                <Radio.Button value="month">æœ¬æœˆ</Radio.Button>
                                                <Radio.Button value="week">æœ¬å‘¨</Radio.Button>
                                                <Radio.Button value="today">æœ¬æ—¥</Radio.Button>
                                            </Radio.Group>
                                        }>
                                            <div ref={chartRef} style={{ height: 300 }}></div>
                                        </Card>
                                    </Col>
                                    <Col span={12}>
                                        <Card title="ä½“è´¨åˆ†å¸ƒ" className="table-card" bordered={false} extra={
                                            <Radio.Group value={timeRange} onChange={e => setTimeRange(e.target.value)} size="small">
                                                <Radio.Button value="all">å…¨éƒ¨</Radio.Button>
                                                <Radio.Button value="month">æœ¬æœˆ</Radio.Button>
                                                <Radio.Button value="week">æœ¬å‘¨</Radio.Button>
                                                <Radio.Button value="today">æœ¬æ—¥</Radio.Button>
                                            </Radio.Group>
                                        }>
                                            <div ref={constitutionChartRef} style={{ height: 300 }}></div>
                                        </Card>
                                    </Col>
                                </Row>
                                <Row gutter={[24, 24]} style={{ marginTop: 24 }}>
                                    <Col span={24}>
                                        <Card title="å­£èŠ‚æ€§ç»Ÿè®¡" className="table-card" bordered={false} extra={
                                            <Radio.Group value={timeRange} onChange={e => setTimeRange(e.target.value)} size="small">
                                                <Radio.Button value="spring">æ˜¥å­£</Radio.Button>
                                                <Radio.Button value="summer">å¤å­£</Radio.Button>
                                                <Radio.Button value="autumn">ç§‹å­£</Radio.Button>
                                                <Radio.Button value="winter">å†¬å­£</Radio.Button>
                                            </Radio.Group>
                                        }>
                                            <Text type="secondary">å­£èŠ‚æ€§ç—…ç—‡åˆ†å¸ƒæƒ…å†µï¼Œå¯ååŠ©åˆ†æå­£èŠ‚ä¸ç–¾ç—…çš„å…³è”æ€§ã€‚</Text>
                                        </Card>
                                    </Col>
                                </Row>
                            </antd.Tabs.TabPane>
                            <antd.Tabs.TabPane tab="è¯å‹ç®¡ç†" key="2">
                                <Card title="è¯å‹åˆ—è¡¨" bordered={false} extra={
                                    <Search placeholder="æœç´¢è¯å‹åç§°" onSearch={v => { setKeyword(v); setCurrent(1); }} style={{ width: 250 }} />
                                }>
                                    <Table 
                                        columns={columns} 
                                        dataSource={data} 
                                        rowKey="id" 
                                        loading={loading}
                                        pagination={{ current, pageSize, total, onChange: (p, s) => { setCurrent(p); setPageSize(s); } }}
                                    />
                                </Card>
                            </antd.Tabs.TabPane>
                            <antd.Tabs.TabPane tab="è¯Šæ–­è®°å½•" key="3">
                                <Card title="æœ€è¿‘æ‚£è€…è¯Šæ–­è®°å½•" bordered={false}>
                                    <Table 
                                        columns={recordColumns} 
                                        dataSource={diagnosisRecords} 
                                        rowKey="id" 
                                        loading={recordLoading}
                                        pagination={{ current: recordCurrent, pageSize: 10, total: recordTotal, onChange: (p) => setRecordCurrent(p) }}
                                    />
                                </Card>
                            </antd.Tabs.TabPane>
                            <antd.Tabs.TabPane tab="ç©´ä½ç®¡ç†" key="4">
                                <AcupunctureManager />
                            </antd.Tabs.TabPane>
                            <antd.Tabs.TabPane tab="ç—‡çŠ¶å¯¹ç…§ç®¡ç†" key="5">
                                <SymptomComparisonManager />
                            </antd.Tabs.TabPane>
                            <antd.Tabs.TabPane tab="ä¸­åŒ»å¸¸è¯†ç®¡ç†" key="6">
                                <KnowledgeManager />
                            </antd.Tabs.TabPane>
                        </antd.Tabs>
                    </Content>

                    <Modal title={editingItem ? 'ç¼–è¾‘è¯å‹' : 'æ–°å¢è¯å‹'} visible={isModalVisible} onOk={async () => {
                        const values = await form.validateFields();
                        await api.saveSyndrome({ ...values, id: editingItem?.id });
                        message.success('ä¿å­˜æˆåŠŸ');
                        setIsModalVisible(false);
                        loadData();
                    }} onCancel={() => setIsModalVisible(false)}>
                        <Form form={form} layout="vertical">
                            <Form.Item name="name" label="è¯å‹åç§°" rules={[{ required: true }]}>
                                <Input />
                            </Form.Item>
                            <Form.Item name="description" label="è¾¨è¯æè¿°" rules={[{ required: true }]}>
                                <Input.TextArea rows={4} />
                            </Form.Item>
                            <Form.Item name="treatment_principle" label="æ²»æ³•åŸåˆ™">
                                <Input />
                            </Form.Item>
                        </Form>
                    </Modal>
                </Layout>
            );
        };

        const App = () => {
            const [user, setUser] = useState(localStorage.getItem('admin_user'));
            return user ? 
                <AdminPanel user={user} onLogout={() => { localStorage.removeItem('admin_user'); setUser(null); }} /> : 
                <LoginPage onLogin={u => { localStorage.setItem('admin_user', u); setUser(u); }} />;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
